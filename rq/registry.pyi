# -*- coding: utf-8 -*-
#
# Copyright 2020 NVIDIA Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import datetime
from abc import abstractmethod

from redis.client import Pipeline, Redis

from .compat import as_text as as_text, utc as utc
from .connections import resolve_connection as resolve_connection
from .defaults import DEFAULT_FAILURE_TTL as DEFAULT_FAILURE_TTL
from .exceptions import InvalidJobOperation as InvalidJobOperation, NoSuchJobError as NoSuchJobError
from .job import Job as Job, JobStatus as JobStatus
from .queue import Queue as Queue
from .utils import backend_class as backend_class, current_timestamp as current_timestamp
from typing import Any, Optional, Dict, Type, Iterable, Sequence, Union, List


class BaseRegistry:
    job_class: Type[Job] = ...
    key_template: str = ...
    name: str = ...
    connection: Redis = ...
    key: str = ...
    def __init__(
        self,
        name: str = ...,
        connection: Optional[Redis] = ...,
        job_class: Optional[Type[Job]] = ...,
        queue: Optional[Queue] = ...,
    ) -> None: ...
    def __len__(self) -> int: ...
    def __eq__(self, other: "BaseRegistry") -> bool: ...
    def __contains__(self, item: Union[str, Job]) -> bool: ...
    @property
    def count(self) -> int: ...
    def add(self, job: Job, ttl: int = ..., pipeline: Optional[Pipeline] = ...) -> None: ...
    def remove(self, job: Job, pipeline: Optional[Pipeline] = ..., delete_job: bool = ...) -> None: ...
    def get_expired_job_ids(self, timestamp: Optional[int] = ...) -> List[str]: ...
    def get_job_ids(self, start: int = ..., end: int = ...) -> List[str]: ...
    def get_queue(self) -> Queue: ...
    def get_expiration_time(self, job: Job) -> datetime.datetime: ...
    @abstractmethod
    def cleanup(self, timestamp: Optional[int] = ...) -> None: ...

class StatusJobRegistryMeta(type):
    _mapping: Dict[str, Type["StatusJobRegistry"]] = ...

    def __new__(mcs, name, bases, dct) -> Type["StatusJobRegistry"]: ...
    def get_registry(self, status: str) -> Type["StatusJobRegistry"]: ...
    @classmethod
    def get_registries(mcs) -> Iterable[Type["StatusJobRegistry"]]: ...

class StatusJobRegistry(BaseRegistry, metaclass=StatusJobRegistryMeta):
    STATUSES: Sequence[str] = ...

class StartedJobRegistry(StatusJobRegistry):
    key_template: str = ...
    def cleanup(self, timestamp: Optional[int] = ...) -> None: ...

class FinishedJobRegistry(StatusJobRegistry):
    key_template: str = ...
    def cleanup(self, timestamp: Optional[int] = ...) -> None: ...

class FailedJobRegistry(StatusJobRegistry):
    key_template: str = ...
    def cleanup(self, timestamp: Optional[int] = ...) -> None: ...
    def add(
        self, job: Job, ttl: Optional[int] = ..., exc_string: str = ..., pipeline: Optional[Pipeline] = ...
    ) -> None: ...
    def requeue(self, job_or_id: Union[str, Job]): ...

class CancelledJobRegistry(FailedJobRegistry):
    pass

class DeferredJobRegistry(StatusJobRegistry):
    key_template: str = ...
    def cleanup(self, timestamp: Optional[int] = ...) -> None: ...

class ScheduledJobRegistry(StatusJobRegistry):
    key_template: str = ...
    def get_jobs_to_enqueue(self, timestamp: Optional[int] = ...) -> List[str]: ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def schedule(self, job: Job, scheduled_datetime: Any, pipeline: Optional[Pipeline] = ...) -> None: ...
    def cleanup(self, timestamp: Optional[int] = ...) -> None: ...
    def remove_jobs(self, timestamp: Optional[int] = ..., pipeline: Optional[Pipeline] = ...) -> None: ...
    def get_jobs_to_schedule(self, timestamp: Optional[int] = ...) -> List[str]: ...
    def get_scheduled_time(self, job_or_id: Union[str, Job]) -> datetime.datetime: ...

def clean_registries(queue: Queue) -> None: ...
