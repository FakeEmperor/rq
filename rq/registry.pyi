# -*- coding: utf-8 -*-
#
# Copyright 2020 NVIDIA Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from redis.client import Pipeline

from .compat import as_text as as_text, utc as utc
from .connections import resolve_connection as resolve_connection
from .defaults import DEFAULT_FAILURE_TTL as DEFAULT_FAILURE_TTL
from .exceptions import InvalidJobOperation as InvalidJobOperation, NoSuchJobError as NoSuchJobError
from .job import Job as Job, JobStatus as JobStatus
from .queue import Queue as Queue
from .utils import backend_class as backend_class, current_timestamp as current_timestamp
from typing import Any, Optional

class BaseRegistry:
    job_class: Any = ...
    key_template: str = ...
    name: Any = ...
    connection: Any = ...
    key: Any = ...
    def __init__(
        self,
        name: str = ...,
        connection: Optional[Any] = ...,
        job_class: Optional[Any] = ...,
        queue: Optional[Any] = ...,
    ) -> None: ...
    def __len__(self): ...
    def __eq__(self, other: Any) -> Any: ...
    def __contains__(self, item: Any): ...
    @property
    def count(self): ...
    def add(self, job: Job, ttl: int = ..., pipeline: Optional[Pipeline] = ...): ...
    def remove(self, job: Job, pipeline: Optional[Pipeline] = ..., delete_job: bool = ...): ...
    def get_expired_job_ids(self, timestamp: Optional[Any] = ...): ...
    def get_job_ids(self, start: int = ..., end: int = ...): ...
    def get_queue(self): ...
    def get_expiration_time(self, job: Job): ...

class StartedJobRegistry(BaseRegistry):
    key_template: str = ...
    def cleanup(self, timestamp: Optional[Any] = ...): ...

class FinishedJobRegistry(BaseRegistry):
    key_template: str = ...
    def cleanup(self, timestamp: Optional[Any] = ...) -> None: ...

class FailedJobRegistry(BaseRegistry):
    key_template: str = ...
    def cleanup(self, timestamp: Optional[Any] = ...) -> None: ...
    def add(
        self, job: Job, ttl: Optional[Any] = ..., exc_string: str = ..., pipeline: Optional[Pipeline] = ...
    ) -> None: ...
    def requeue(self, job_or_id: Any): ...

class DeferredJobRegistry(BaseRegistry):
    key_template: str = ...
    def cleanup(self) -> None: ...

class ScheduledJobRegistry(BaseRegistry):
    key_template: str = ...
    get_jobs_to_enqueue: Queue = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def schedule(self, job: Job, scheduled_datetime: Any, pipeline: Optional[Pipeline] = ...): ...
    def cleanup(self) -> None: ...
    def remove_jobs(self, timestamp: Optional[Any] = ..., pipeline: Optional[Pipeline] = ...): ...
    def get_jobs_to_schedule(self, timestamp: Optional[Any] = ...): ...
    def get_scheduled_time(self, job_or_id: Any): ...

def clean_registries(queue: Queue) -> None: ...
