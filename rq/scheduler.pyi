# -*- coding: utf-8 -*-
#
# Copyright 2020 NVIDIA Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import datetime
from multiprocessing.context import Process

from redis import Redis

from .job import Job as Job
from .logutils import setup_loghandlers as setup_loghandlers
from .queue import Queue as Queue
from .registry import ScheduledJobRegistry as ScheduledJobRegistry
from .utils import current_timestamp as current_timestamp, enum as enum
from typing import Any, Optional, List, Set, Union, Iterable

SCHEDULER_KEY_TEMPLATE: str
SCHEDULER_LOCKING_KEY_TEMPLATE: str

class RQScheduler:
    Status: Any = ...

    lock_acquisition_time: Optional[datetime.datetime] = ...
    interval: int = ...

    _queue_names: Set[str] = ...
    _acquired_locks: Set[str] = ...
    _scheduled_job_registries: List[ScheduledJobRegistry] = ...
    _connection_kwargs: Any = ...
    _connection: Any = ...
    _stop_requested: bool = ...
    _status: str = ...
    _process: Optional[Process] = ...

    def __init__(self, queues: Iterable[Union[str, Queue]], connection: Redis, interval: int = ...) -> None: ...

    @property
    def connection(self) -> Redis: ...
    @property
    def acquired_locks(self) -> Set[str]: ...
    @property
    def status(self) -> str: ...
    @property
    def should_reacquire_locks(self) -> bool: ...

    def acquire_locks(self, auto_start: bool = ...): ...
    def prepare_registries(self, queue_names: Optional[Any] = ...) -> None: ...
    def request_stop(self, signum: Optional[Any] = ..., frame: Optional[Any] = ...) -> None: ...
    def enqueue_scheduled_jobs(self) -> None: ...

    def start(self) -> Process: ...
    def work(self) -> None: ...
    def stop(self) -> None: ...
    def heartbeat(self) -> None: ...

    def _install_signal_handlers(self) -> None: ...

    @classmethod
    def get_locking_key(cls, name: Any): ...


def run(scheduler: Any) -> None: ...
def parse_names(queues_or_names: Iterable[Union[str, Queue]]): ...
