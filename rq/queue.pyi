# -*- coding: utf-8 -*-
#
# Copyright 2020 NVIDIA Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from redis.client import Pipeline, Redis

from .compat import as_text as as_text, string_types as string_types, total_ordering as total_ordering, utc as utc
from .connections import resolve_connection as resolve_connection
from .defaults import DEFAULT_RESULT_TTL as DEFAULT_RESULT_TTL
from .exceptions import DequeueTimeout as DequeueTimeout, NoSuchJobError as NoSuchJobError
from .job import Job as Job, JobStatus as JobStatus, Retry
from .serializers import resolve_serializer as resolve_serializer
from .utils import (
    backend_class as backend_class,
    import_attribute as import_attribute,
    parse_timeout as parse_timeout,
    utcnow as utcnow,
)
from typing import Any, Optional, Iterable, Union


def compact(lst: Any): ...

class Queue:
    job_class: Any = ...
    DEFAULT_TIMEOUT: int = ...
    redis_queue_namespace_prefix: str = ...
    redis_queues_keys: str = ...
    @classmethod
    def all(cls, connection: Optional[Any] = ..., job_class: Optional[Any] = ..., serializer: Optional[Any] = ...): ...
    @classmethod
    def from_queue_key(
        cls,
        queue_key: Any,
        connection: Optional[Any] = ...,
        job_class: Optional[Any] = ...,
        serializer: Optional[Any] = ...,
    ): ...
    connection: Any = ...
    name: Any = ...
    _key: Any = ...
    _default_timeout: Any = ...
    _is_async: Any = ...
    serializer: Any = ...
    redis_server_version: Any = ...
    def __init__(
        self,
        name: str = ...,
        default_timeout: Optional[Any] = ...,
        connection: Optional[Any] = ...,
        is_async: bool = ...,
        job_class: Optional[Any] = ...,
        serializer: Optional[Any] = ...,
        **kwargs: Any
    ) -> None: ...
    def __len__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def __iter__(self) -> Any: ...
    def get_redis_server_version(self): ...
    @property
    def key(self): ...
    @property
    def registry_cleaning_key(self): ...
    def acquire_cleaning_lock(self): ...
    def empty(self): ...
    def delete(self, delete_jobs: bool = ...) -> None: ...
    def is_empty(self): ...
    @property
    def is_async(self): ...
    def fetch_job(self, job_id: Any): ...
    def get_job_position(self, job_or_id: Any): ...
    def get_job_ids(self, offset: int = ..., length: int = ...): ...
    def get_jobs(self, offset: int = ..., length: int = ...): ...
    @property
    def job_ids(self): ...
    @property
    def jobs(self): ...
    @property
    def count(self): ...
    @property
    def failed_job_registry(self): ...
    @property
    def started_job_registry(self): ...
    @property
    def finished_job_registry(self): ...
    @property
    def deferred_job_registry(self): ...
    @property
    def scheduled_job_registry(self): ...
    def remove(self, job_or_id: Any, pipeline: Optional[Pipeline] = ...): ...
    def compact(self) -> None: ...
    def push_job_id(self, job_id: Any, pipeline: Optional[Pipeline] = ..., at_front: bool = ...) -> None: ...
    def create_job(
        self,
        func: Any,
        args: Optional[tuple] = ...,
        kwargs: Optional[dict] = ...,
        timeout: Optional[int] = ...,
        result_ttl: Optional[int] = ...,
        ttl: Optional[int] = ...,
        failure_ttl: Optional[int] = ...,
        description: Optional[str] = ...,
        depends_on: Union[None, str, Job, Iterable[Union[str, Job]]] = ...,
        job_id: Optional[str] = ...,
        meta: Optional[dict] = ...,
        status: Optional[Union[str, JobStatus]] = ...,
        retry: Optional[Retry] = ...,
    ): ...
    def enqueue_call(
        self,
        func: Any,
        args: Optional[tuple] = ...,
        kwargs: Optional[dict] = ...,
        timeout: Optional[int] = ...,
        result_ttl: Optional[int] = ...,
        ttl: Optional[int] = ...,
        failure_ttl: Optional[int] = ...,
        description: Optional[str] = ...,
        depends_on: Union[None, str, Job, Iterable[Union[str, Job]]] = ...,
        job_id: Optional[str] = ...,
        at_front: bool = ...,
        meta: Optional[dict] = ...,
        retry: Optional[Retry] = ...,
    ): ...
    def run_job(self, job: Job): ...
    @classmethod
    def parse_args(cls, f: Any, *args: Any, **kwargs: Any): ...
    def enqueue(self, f: Any, *args: Any, **kwargs: Any): ...
    def enqueue_at(self, datetime: Any, f: Any, *args: Any, **kwargs: Any): ...
    def schedule_job(self, job: Job, datetime: Any, pipeline: Optional[Pipeline] = ...): ...
    def enqueue_in(self, time_delta: Any, func: Any, *args: Any, **kwargs: Any): ...
    def enqueue_job(self, job: Job, pipeline: Optional[Pipeline] = ..., at_front: bool = ...): ...
    def enqueue_dependents(self, job: Job, pipeline: Optional[Pipeline] = ...) -> None: ...
    def pop_job_id(self): ...
    @classmethod
    def lpop(cls, queue_keys: Any, timeout: Any, connection: Optional[Any] = ...): ...
    @classmethod
    def dequeue_any(
        cls, queues: Any, timeout: Any, connection: Optional[Redis] = ..., job_class: Optional[Any] = ...
    ): ...
    def __eq__(self, other: Any) -> Any: ...
    def __lt__(self, other: Any) -> Any: ...
    def __hash__(self) -> Any: ...
    def __repr__(self): ...
    def __str__(self): ...
